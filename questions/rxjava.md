### Реактивное программирование 

Парадигма программирования, ориентированная на потоки данных и распространение изменений

### Что знаешь про Rx? В чем главное преимущество Rx?

Ошибки для цепочки падают в один метод. Легко прекратить выполнение через disposable-объект
Можно выстроить цепочки операций, задать поток, в котором будет исполняться observable и в который будет возвращаться результат.

### Используемые объекты (Observable, Completable, Single)

**Observable** – базовый класс, реализующий паттерн «наблюдаемый». Облегчает параллельные операции, так как не блокирует поток в ожидании данных. Может эмитить n элементов, выполниться успешно или выдать ошибку.
**Completable** – либо успешно выполняется либо выдает ошибку. Не возвращает никаких данных.
**Single** –возвращает единожды данные или выдает ошибку. 
**Maybe** –возвращает единожды данные или успешно выполнится или выдает ошибку.
**Flowable** – observable с поддержкой backpressure (позволяет притормозить источники данных, если не успеваем обработать уже полученные из них данные). Может эмитить n элементов, выполниться успешно или выдать ошибку.

### В чем разница между Reduce, scan, tolist?

Todo

### В чем разница между map(), concatMap(), switchMap() и flatMap() в RxJava?

**map** – преобразует каждый элемент.
**flatMap** - для каждого элемента исходной последовательности возвращает новую последовательность, а потом объединяет их все в одну результирующую последовательность без сохранения очередности.
**switchMap** – аналогично flatMap, но отписывается от последовательности, полученной от предыдущего элемента, переключается на новую и ждёт результатов от неё.
**concatMap** – новый Observable сохраняет такой же порядок элементов, как и в предыдущем.

### Как создавать параллельные сетевые запросы в RxJava?

Zip – запросы будут выполняться параллельно. Результат – только после выполнения всех. 

### Объединение нескольких длительных операций для единовременного получения результата выполнения всех этих операций

Объединить можно через zip с указанием входящих/результирующих типов и того, как будет происходить конвертация данных.

### Быстрое создание observable - какие операторы

Just(Any), fromCallable{}, fromIterable(), create<>{}, empty(), error(), never(), timer(), interval()

### Для чего используются методы subscribeOn, observeOn

**subscribeOn** – в каком потоке будет выполняться observable
**observeOn** – в какой поток будут возвращены результаты

### Отличия Schedulers.io и Schedulers.newThread

**io** – использует пул потоков
**newThread** – для каждой задачи создает новый тред

### Что такое Disposable, CompositeDisposable

**Disposable** – класс, через который можно отписаться от событий. Получается при подписке.
**CompositeDisposable** – класс, который может объединить несколько disposable и отписаться через все одновременно.

### Hot/cold observables

**Cold Observable** (retrofit requests): 

* Не рассылает объекты, пока на него не подписался хотя бы один подписчик; 
* Если observable имеет несколько подписчиков, то он будет рассылать всю последовательность объектов каждому подписчику.

**Hot Observable**: 

* Рассылает объекты, когда они появляются, независимо от того есть ли подписчики; 
* Каждый новый подписчик получает только новые объекты, а не всю последовательность.