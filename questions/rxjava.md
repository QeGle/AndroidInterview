### Реактивное программирование 

Парадигма программирования, ориентированная на потоки данных и распространение изменений

### Что знаешь про Rx? В чем главное преимущество Rx?

Ошибки для цепочки падают в один метод. 
Легко прекратить выполнение через disposable-объект.
Можно выстроить цепочки операций, задать поток, в котором будет исполняться observable и в который будет возвращаться результат.

### Используемые объекты (Observable, Completable, Single)

**Observable** – базовый класс, реализующий паттерн «наблюдаемый». Облегчает параллельные операции, так как не блокирует поток в ожидании данных. Может эмитить n элементов, выполниться успешно или выдать ошибку.
**Completable** – либо успешно выполняется либо выдает ошибку. Не возвращает никаких данных.
**Single** –возвращает единожды данные или выдает ошибку. 
**Maybe** –возвращает единожды данные или успешно выполнится или выдает ошибку.
**Flowable** – observable с поддержкой backpressure (позволяет притормозить источники данных, если не успеваем обработать уже полученные из них данные). Может эмитить n элементов, выполниться успешно или выдать ошибку.

### В чем разница между map(), concatMap(), switchMap() и flatMap() в RxJava?

**map** – преобразует каждый элемент.
**flatMap** - для каждого элемента исходной последовательности возвращает новую последовательность, а потом объединяет их все в одну результирующую последовательность без сохранения очередности.
**switchMap** – аналогично flatMap, но отписывается от последовательности, полученной от предыдущего элемента, переключается на новую и ждёт результатов от неё.
**concatMap** – новый Observable сохраняет такой же порядок элементов, как и в предыдущем.

### Как создавать параллельные сетевые запросы в RxJava?

Zip – запросы будут выполняться параллельно. Результат – только после выполнения всех. 

### Объединение нескольких длительных операций для единовременного получения результата выполнения всех этих операций

Объединить можно через zip с указанием входящих/результирующих типов и того, как будет происходить конвертация данных.

### Быстрое создание observable - какие операторы

Just(Any), fromCallable{}, fromIterable(), create<>{}, empty(), error(), never(), timer(), interval()

### Для чего используются методы subscribeOn, observeOn

**subscribeOn** – в каком потоке будет выполняться observable
**observeOn** – в какой поток будут возвращены результаты

### Отличия Schedulers.io и Schedulers.newThread

**io** – использует пул потоков
**newThread** – для каждой задачи создает новый тред

### Что такое Disposable, CompositeDisposable

**Disposable** – класс, через который можно отписаться от событий. Получается при подписке.
**CompositeDisposable** – класс, который может объединить несколько disposable и отписаться через все одновременно.

### Оператор reduce()

Todo

### Оператор toList()

Объекдинаяет все выпущенные элементы в список и в результате мы получаем список значений всех эмитов

### Оператор Timeout()

Добавляет к цепочке правило таймаута, в этом случае, если по истечению врерни, указанном в операторе не было эмита, то цепочка завершается с TimeOutException. Так же мы можем добавить к оператору Timeout другой Observable, который эмитится только в случае срабатывания условия таймаута, т.е. если прошло время и не было эмита из целевой цепочки - происходит вызов Observable , указанного в таймауте

### Оператор Cache(), Buffer()

**Cache** - собирает в одну пачку все эмиты изначального Observable, сохраняя их порядок (в том же, в какой их эмитил изначальный источник) и эмитит их
**Buffer** - позволяет собирать эмиты в пачки по N штук, т.е. если у нас есть 10 эмитов, но при подписке мы использовали buffer(3), то после подписки мы будем получать результаты не по 1, а по 3 сразу

### Оператор Retry(RetryWhen), Repeat(RepeatWhen)

**Retry(RetryWhen)** - оператор повтора вызова исходного (переподписывания) Observable, в случае срабатывания ошибки (onError). RetryWhen позволяет выбирать условие при котором мы делаем повторный вызов Observable (например при определенном типе исключения). Т.е. вместо onError вызывется еще один onNext
**Repeat(RepeatWhen)** - оператор повтора исходного вызова (переподписывания), срабатывающий при заходе в onComplete.

### Оператор OnErrorResumeNext()

В случае захода в блок onError вместо onError этот оператор бросает дальше в цепочку другой Observable

### Hot/cold observables

**Cold Observable** (retrofit requests): 

* Не рассылает объекты, пока на него не подписался хотя бы один подписчик; 
* Если observable имеет несколько подписчиков, то он будет рассылать всю последовательность объектов каждому подписчику.

**Hot Observable**: 

* Рассылает объекты, когда они появляются, независимо от того есть ли подписчики; 
* Каждый новый подписчик получает только новые объекты, а не всю последовательность.