### Как изучал/изучаешь платформу (источники информации - книги, сайты)

Medium, habr, podcasts, telegram channels, documentation, google codelabs

### Основные компоненты Android приложения

Activity, service, content provider, broadcast receiver

### Жизненный цикл Activity

Launch -> onCreate -> onStart -> onResume | running | onPause -> onStop -> onDestroy -> shutdown
restart from background - onStop -> onRestart -> onStart

### Каким способом передаются данные между Activity

Через intent (putExtra) или через глобальные переменные/eventBus и прочее

### При каком из callback Activity уже отрисована?

ViewTreeObserver – onGlobalLayout. Слот вызывается при изменении глобального макета и, соответственно, при первой отрисовке активности.

### Жизненный цикл Fragment

add -> onAttach -> onCreate -> onCreateView-> onActivityCreated -> onStart -> onResume | active | onPause -> onStop -> onDestroyView-> onDestroy -> onDetach -> destroyed	restart from background - onDestroyView-> onCreateView

### Передать данные между двумя фрагментами на одном Activity

Активность как слушатель для эвентов во фрагментах. И через нее при эвенте в одном данные передаются в другую. Также глобальные переменные, eventBus.

### У фрагмента есть метод, который можно переопределить, он зовется getview и помечен из коробки как nullable. Почему так? Что будет если в getview вернуть null?

Получим «безголовый(headless)» fragment

### Зачем нужен Headless fragment (без View и с setReatinInstance = true)?

Для хранения данных. В основном нужен для того, чтобы безболезненно пережить поворот экрана так как не пересоздается.

### Отличия Headless fragment и service

**Fragment** – инкапсуляция данных (хранение данных)
**Service** – инкапсуляция обработки (долгосрочные задачи)

### Какие бывают сервисы

**Foreground** – операции, которые заметны пользователю (например проигрывание музыки). Обязательно показывают уведомление
**Background** – незаметные для пользователя операции. Имеют ограничение с api>=26 на работу, когда приложение находится в фоне 
**Bound** - когда сервис связан с каким-либо компонентом. Работает пока есть связь с хотя бы одним. Если все связи исчезают – уничтожается.
Вне зависимости от типа – должны быть прописаны в манифесте

### Жизненный цикл Service

Зависит от функции, при помощи которой запущена:

* **startService** – onCreate -> onStartService |running| onDestroy – shutdown 
* **bindService** – onCreate -> onBind - clients bound. Last client call unbindService – onUnbind -> onDestroy - shutdown

#### В чем разница между Service и IntentService? Как они используются?

|             | Service                | IntentService                                                |
| ----------- | ---------------------- | ------------------------------------------------------------ |
| When to use | Короткие задачи без UI | Для задач, которые могут блокировать UI                      |
| Trigger     | onStartService         | intent                                                       |
| From        | Any threads            | Main thread                                                  |
| Runs on     | Main thread            | Отдельный work thread                                        |
| Limitations | May block main thread  | Невозможно распараллелить задачи.Intents помещаются в очередь в одном и том же потоке |

### Как общаться с сервисом?

Несколько вариантов: 

* создать bind service и получить его экземпляр через Ibinder
* BroadcastReceiver
* ResultReceiver, упакованный в интент
* EventBus

### Опишите интерфейс ibinder.

Этот интерфейс описывает абстрактный протокол для взаимодействия с удаленным объектом. Можно использовать для взаимодействия с сервисом

### Как достигается взаимодействие? Мы переопределили интерфейс ibinder, как будет строиться взаимодействие?

Можем добавить в свою реализацию методы и дергать их. Также можем вернуть ссылку на сервис и дергать методы напрямую у сервиса

### Жизненный цикл View

onAttachedToWindow -> onMeasure -> onLayout -> onDraw
**invalidate** -> onDraw -> ...
**requestLayout** -> OnMeasure -> …
todo картинка надо

### Что такое View, какие методы у него есть и что они делают?

Основная часть для построения всего ui в приложении. Родительский для всех остальных элементов ui. Представляет из себя простой прямоугольник, который реагирует на действия пользователя.

### Custom view - какая должна быть семантика методов view? Для чего каждый метод нужен? 

Есть несколько основных групп для методов:

**Layouton measure** - вычисление размеров для себя и дочерних элементов, 

* **onLayout** - применение размеров для себя и дочерних элементов,
* **onSizeChanged** - изменение размеров.

**Drawing**

* **onDraw** – отрисовка контента.

**Обработка событий**

* **onKeyDown** - 	при нажатии кнопки,
* **onKeyUp** – при отпускании кнопки,
* **onTrackballEvent** – при событиях с трекбола,
* **onTouchEvent** – при нажатиях на экран.

**Фокус**

* **onFocusChanged** - при изменении фокуса на самой вьюхе,
* **onWindowFocusChanged** – при изменении фокуса на окне, содержащим эту вьюху.

**Attaching**

* **onAttachedToWindow** – прикрепление. окну
* **onDetachedFromWindow** – открепление от окна
* **onWindowVisibilityChanged** – смена видимости окна, содержащего вьюху.

### Чем отличаются методы view и viewgroup?

ViewGroup – невидимый контейнер. Может содержать в себе как view, так и другие ViewGroup. Так же viewgroup является базовым для всех layout’ов

### Как можно выявить проблемы в скорости UI и устранить их?

**Визуально** - торможение ui,
**Консольно** - adb shell dumpsys gfxinfo <pckgname> – при девайсе с апи>=23 выдаст данные по скорости работы приложения. Если добавить к команде framestats можно получить cvs данные за последние 120 кадров.Также уведомления в консоли будет выдавать choreographer

### Что такое Intent, какие бывают

Формат сообщения, которым можно запросить выполнение действия у компонента другого приложения. Могут использоваться для запуска activity, service и доставки широковещательных сообщений между приложениями.

### Явный и неявный Intent

**Явный** – указывается компонент, который нужно запустить.
**Не явный** – указывается действие, которое необходимо совершить.

### Какие layout знаете? Какая разница между LinearLayout и RelativeLayout, ConstraintLayout?

FrameLayout, LinearLayout, RelativeLayout, CoordinatorLayout, AppBarLayout, ConstraintLayout. 
Разница между ними в отношениях между дочерними элементами и в скорости работы.

### Что делает android.manifest?

Содержит важную инфу о приложении для системы.
Описывает компоненты приложения.
Описывает разрешения, которые должны быть выданы приложению для доступа к защищенным частям апи.
Описывает необходимые элементы устройства, необходимые для функционирования приложения (позволяет отфильтровать на уровне маркета девайсы на которые можно установить приложения).
Описывает внешние события, на которые может реагировать приложение.

### Что такое BroadcastReceiver?

Базовый класс, который получает и обрабатывает широковещательные сообщения

### Сколько вариантов объявления broadcastreciever и чем они отличаются?

Есть два варианта объявления:

* статически через <receiver> тэг в манифесте
* через Context#registerReceiver

В первом случае ресивер регистрируется в момент установки приложения и получает широковещательные сообщения до удаления с устройства, а во втором с момента регистрации до уничтожения контекста.

### Способы хранения данных в Android приложении

Есть 4 варианта хранения данных в приложении:

* **SharedPreferences** - хранение данных в формате ключ-значение. можно использовать для хранения таких типов данных как int, float, long, string. Чистятся при отчистке всех данных приложения и удалении приложения.
* **InternalStorage** - хранит данные в памяти устройства в виде файлов. Файлы, сохраненные для вашего приложения, по умолчанию приватны, и другое приложение не может получит к ним доступ. Когда пользователь удаляет приложение, файлы, связанные с приложением, также удаляются. Хранимые таким образом данные разделяются по двум типам – кэш и файлы. Первые удаляются при чистке кэша, вторые аналогично SharedPreferences. Доступны через проводник.
* **ExternalStorage** - хранит данные в общем хранилище. Все приложения имеют доступ к этим данным.
* **SQLite Database** - хранит данные в структурированном виде в базе данных. Android полностью поддерживает SQLite. Вне приложения база данных недоступна.

### Способы работы с интернетом (отправка запросов)

OkHttpClient, HttpUrlConnection, Retrofit

### Почему мы не грузим сеть в основном потоке в Андроид

NetworkOnMainThreadException

### Выполнение длительных операций – способы

AsyncTask, Thread, Service, Coroutines, Rx, WorkManager

### В чем отличие AsyncTask от Thread, минусы AsyncTask?

|             | Thread                                                       | AsyncTask                                                    |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| When to use | В основном для долгих задач.Несколько тредов для параллельности | Для относительно долгих задач (могут блокировать UI)         |
| Trigger     | start()                                                      | execute()                                                    |
| From        | Any threads                                                  | Main thread                                                  |
| Runs on     | Сам себе тред                                                | worker thread, но пушит прогресс в main.                     |
| Limitations | Ручное управление потоками.                                  | 1 инстанс может быть выполнен только единожды. Должен быть создан и запущен в main |

### Работа с компонентом Spinner

Выпадающий список с отображение выбранного элемента. Работает в 2 вариантах – выпадающий список и диалоговое окно. Для работы необходим адаптер.

### Работа с компонентом RecyclerView (adapter, viewHolder), для чего используются viewType

Для работы необходимо задать LayoutManager (отвечает за размещение элементов) и RecyclerView.Adapter. Адаптер управляет представлением каждого элемента в списке.
Представление назначается в методе onBindViewHolder()
ViewType нужен для отображения различных представлений в одном списке.

### Чем отличаются RecyclerView от ListView?

В RV используется viewHolder, что снижает производительность.
В RV можно задать LayoutManager/ItemAnimator/ItemDecorator
В RV ячейки переиспользуются.

### В чем разница между Serializable и Parcelable? Что предпочтительнее использовать в Android?

Parcelable быстрее Serializable, так как для parcelable мы пишем сериализацию сами, а для Serializable используется Reflection API. 
Parcelable занимает больше времени для реализации в отличии от Serializable.
Serializable создает много временных объектов.
Parcelable может быть передан через Intent.

### Отличие DALVIK от ART, приходилось ли сталкиваться с миграцией с Dalvik на новую технологию ART?

DALVIK компилирует инструкции во время первого запуска, а ART во время установки. В следствии этого программы в ART запускаются быстрее, но используют больше постоянной памяти

### Поворот экрана и способы пережить

Три варианта:

* Забить и пусть перезапускается все,
* Сохранение данных (onSavedInstanceState, viewModels, для сохранения фрагментов – setRetainInstance),
* Самостоятельная обработка изменения (заблокировано изменение системой, но слушается слот onConfigurationChanged).

### Что такое контекст?

Интерфейс для получения глобальной информации о среде приложения. Это абстрактный класс, реализация которого обеспечивается системой Android. Позволяет получить доступ к ресурсам и классам, относящимся к конкретному приложению, а также к дополнительным вызовам для операций на уровне приложения, таких как запуск других активностей, широковещание и получение интентов, и т.д.

### Чем отличается ApplicationContext от ActivityContext?

Оба инстансы контекста, но с различным временем жизни

### Что такое ContextWrapper?

Прокси-реализация контекста, которая просто делегирует все свои вызовы другому контексту. Может быть разделено на подклассы для изменения поведения без изменения исходного контекста.

### Как связаны Activity и Context? Context внутри Activity?

Активность расширяет контекст

### Handler, Looper, MessageQueue

**Handler** – это класс, который используется для работы с очередью сообщений, связанной с потоком. Хэндлер позволяет отправлять сообщения в другие потоки с задержкой или без, а также обрабатывать полученные сообщения. Хэндлер всегда связан с лупером, который в свою очередь связан с каким-либо потоком. При создании хэндлера в конструктор можно передать объект Looper. Если используется дефолтный конструктор, то хэндлер создается на текущем потоке. Если с потоком не связан лупер, то при создании хэндлера бросается RuntimeException.
**Looper** запускает цикл обработки очереди сообщений, связанный с потоком. Поток работает, пока связанный с ним лупер не будет остановлен. Для создания лупера, вызывается статический метод Looper.prepare(). Созданный лупер будет связан с потоком, в котором вызван этот метод.
Очередь реализована классом **MessageQueue**. MessageQueue не имеет публичных методов для работы с сообщениями. Работа с очередью выполняется через методы класса Handler. MessageQueue хранит объекты класса Message. В объекте message можно передать Bundle, который добавляется и получается методами setData() и getData().

### Что такое ContentProvider?

Используется для обмена данными между приложениями или компонентами внутри одного приложения. Управляет доступом к структурированному набору данных. Предоставляет механизмы для определения безопасности данных. 
ContentProvider — это стандартный интерфейс, который соединяет данные в одном процессе с кодом, запущенным в другом процессе.

### Когда мы выгружаем приложение из памяти, что происходит в этот момент? Процесс убивается? Сервис как работает?

Todo

### С помощью чего обрабатываются deep links? Есть ли отличие в работе с deep links на разных версиях Android?

С помощью intentFilter прописанного в манифесте.
App links с 23 апи.

### Что такое Permissons? Есть ли отличие на разных версиях Android?

Разрешения на доступ к данным и определенным системным функциям.4 типа – dangerous, normal, special, signature (для подписанных гугловым ключом).
В зависимости от типа разрешения (dangerous|normal) система может автоматически предоставить доступ или запросить разрешение от пользователя.
До апи 21 – запрос всех разрешений при установке приложения
До 23 – запрос при старте приложения
После 23 – рантайм запросы

### Приходилось ли писать свои Permissons?

Нужно объявить свое разрешение в манифесте. Если есть несколько аппов с одинаковым кастомным разрешением – они должны быть подписаны одним сертификатом чтобы работать корректно.

### Мы хотим, чтобы приложение делало фото, где и что нам надо прописать?

Разрешение на доступ к камере в манифесте, запрос разрешения перед использованием камеры, использование камеры если пользователь разрешил

### Когда уничтожается ViewModel в системе и как называется соответствующий колбек?

**onCleared** - вызывается при полном уничтожении Activity, означает уничтожение инстанса viewModel

### Приходилось ли использовать ProGuard?

Главная задача — поменять имена объектов, классов, методов, тем самым затрудняя анализ кода для реверс-инженера. Помимо этого, он еще и оптимизирует код, удаляя неиспользуемые в программе ресурсы. 

### Как определяете, какой layout надо использовать для смартфона, а какой для планшета? 

Постфикс у папки с нужным типом layout – “-sw600dp” для экранов с шириной>600dp

### Как в коде определите: планшет это или смартфон?

Есть несколько вариантов:

* найти диагональ экрана и по ней разделить устройства,
* добавить кастомный атрибут, например isTablet = false, и для sw600dp переопределить его на true.

### JobScheduler

Апи для планирования различных задач, который снимает с разработчика вопросы о том, когда задаче можно выполниться, каким приемлемым образом предоставить ей возможность выполнения, если это действительно очень нужно, и как при этом не нарушить политику энергосбережения

### JobService

Сервис для выполнения задач JobScheduler
**onStartJob** – выполняется в main thread’е.
**onStopJob** – вызывается когда условия выполнения перестали совпадать. Возвращает true если задача не выполнена и нужно повторить

### WorkManager

Предназначен для отложенных задач, не требующих мгновенного выполнения.
До апи 23 – BroadcastReceiver + AlarmManager
После апи 23 - JobScheduler

### Application

Базовый класс для поддержания состояния приложения. Можно расширить – создав наследника и указав его в манифесте.

### Retrofit

Типобезопасный HTTP Android клиент для взаимодействия с REST-интерфейсами.